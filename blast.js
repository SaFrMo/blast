/****************
    Blast.js
****************/

/*! Blast.js (2.1.0): julian.com/research/blast (C) 2015 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
/*! Vanilla version by Sander Moolin */


/*****************
    Constants
*****************/

const NAME = "blast"
const characterRanges = {
    latinPunctuation: "–—′’'“″„\"(«.…¡¿′’'”″“\")».…!?",
    latinLetters: "\\u0041-\\u005A\\u0061-\\u007A\\u00C0-\\u017F\\u0100-\\u01FF\\u0180-\\u027F"
}
const Reg = {
    /* If the abbreviations RegEx is missing a title abbreviation that you find yourself needing to often escape manually, tweet me: @Shapiro. */
    abbreviations: new RegExp("[^" + characterRanges.latinLetters + "](e\\.g\\.)|(i\\.e\\.)|(mr\\.)|(mrs\\.)|(ms\\.)|(dr\\.)|(prof\\.)|(esq\\.)|(sr\\.)|(jr\\.)[^" + characterRanges.latinLetters + "]", "ig"),
    innerWordPeriod: new RegExp("[" + characterRanges.latinLetters + "]\.[" + characterRanges.latinLetters + "]", "ig"),
    onlyContainsPunctuation: new RegExp("[^" + characterRanges.latinPunctuation + "]"),
    adjoinedPunctuation: new RegExp("^[" + characterRanges.latinPunctuation + "]+|[" + characterRanges.latinPunctuation + "]+$", "g"),
    skippedElements: /(script|style|select|textarea)/i,
    hasPluginClass: new RegExp("(^| )" + NAME + "( |$)", "gi")
}
let delimiterRegex

// getText from Sizzle.js
function getText(elem){
	let node
	let ret = ""
	let i = 0
	const nodeType = elem.nodeType

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node )
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === 'string' ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem )
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
}

/**********************
   Element Variables
**********************/

Element = {
    /* The index of each wrapper element generated by blasting. */
    blastedIndex: 0,
    /* Whether we're just entering this node. */
    nodeBeginning: false,
    /* Keep track of the elements generated by Blast so that they can (optionally) be pushed onto the jQuery call stack. */
    wrappers: Element.wrappers || []
}

/************
   Reverse
************/

function reverse (el, opts) {
    if (opts.debug) console.time("blast reversal");

    let skippedDescendantRoot = false;

    el.classList.remove(NAME + '-root')
    el.removeAttribute('aria-label')

    // TODO: implement reversal?
    // const descendants = Array.from(el.querySelectorAll('.' + NAME))
    // descendants.map(function(desc) {
    //     /* Do not reverse Blast on descendant root elements. (Before you can reverse Blast on an element, you must reverse Blast on any parent elements that have been Blasted.) */
    //     if (!$this.closest("." + NAME + "-root").length) {
    //         const thisParentNode = this.parentNode;
    //
    //         /* Strip the HTML tags off of the wrapper elements by replacing the elements with their child node's text. */
    //         thisParentNode.replaceChild(this.firstChild, this);
    //
    //         /* Normalize() parents to remove empty text nodes and concatenate sibling text nodes. (This cleans up the DOM after our manipulation.) */
    //         thisParentNode.normalize();
    //     } else {
    //         skippedDescendantRoot = true;
    //     }
    //
    // })

    // $this
    //     // .removeClass(NAME + "-root")
    //     // .removeAttr("aria-label")
    //     .find("." + NAME)
    //         .each(function () {
    //         });

    /* Zepto core doesn't include cache-based $.data(), so we mimic data-attr removal by setting it to undefined. */
    if (window.Zepto) {
        $this.data(NAME, undefined);
    } else {
        $this.removeData(NAME);
    }

    if (opts.debug) {
        console.log(NAME + ": Reversed Blast" + ($this.attr("id") ? " on #" + $this.attr("id") + "." : ".") + (skippedDescendantRoot ? " Skipped reversal on the children of one or more descendant root elements." : ""));
        console.timeEnd("blast reversal");
    }
}

/*************************
   Punctuation Escaping
*************************/

/* Escape likely false-positives of sentence-final periods. Escaping is performed by wrapping a character's ASCII equivalent in double curly brackets,
   which is then reversed (deencodcoded) after delimiting. */
function encodePunctuation (text) {
    return text
            /* Escape the following Latin abbreviations and English titles: e.g., i.e., Mr., Mrs., Ms., Dr., Prof., Esq., Sr., and Jr. */
            .replace(Reg.abbreviations, function(match) {
                return match.replace(/\./g, "{{46}}");
            })
            /* Escape inner-word (non-space-delimited) periods. For example, the period inside "Blast.js". */
            .replace(Reg.innerWordPeriod, function(match) {
                return match.replace(/\./g, "{{46}}");
            });
}

/* Used to decode both the output of encodePunctuation() and punctuation that has been manually escaped by users. */
function decodePunctuation (text) {
    return text.replace(/{{(\d{1,3})}}/g, function(fullMatch, subMatch) {
        return String.fromCharCode(subMatch);
    });
}

/******************
   DOM Traversal
******************/

function wrapNode (node, opts) {
    var wrapper = document.createElement(opts.tag);

    /* Assign the element a class of "blast". */
    wrapper.className = NAME;

    /* If a custom class was provided, assign that too. */
    if (opts.customClass) {
        wrapper.className += " " + opts.customClass;

        /* If an opts.customClass is provided, generate an ID consisting of customClass and a number indicating the match's iteration. */
        if (opts.generateIndexID) {
            wrapper.id = opts.customClass + "-" + Element.blastedIndex;
        }
    }

    /* For the "all" delimiter, prevent space characters from collapsing. */
    if (opts.delimiter === "all" && /\s/.test(node.data)) {
        wrapper.style.whiteSpace = "pre-line";
    }

    /* Assign the element a class equal to its escaped inner text. Only applicable to the character and word delimiters (since they do not contain spaces). */
    if (opts.generateValueClass === true && !opts.search && (opts.delimiter === "character" || opts.delimiter === "word")) {
        var valueClass,
            text = node.data;

        /* For the word delimiter, remove adjoined punctuation, which is unlikely to be desired as part of the match -- unless the text
           consists solely of punctuation (e.g. "!!!"), in which case we leave the text as-is. */
        if (opts.delimiter === "word" && Reg.onlyContainsPunctuation.test(text)) {
            /* E: Remove punctuation that's adjoined to either side of the word match. */
            text = text.replace(Reg.adjoinedPunctuation, "");
        }

        valueClass = NAME + "-" + opts.delimiter.toLowerCase() + "-" + text.toLowerCase();

        wrapper.className += " " + valueClass;
    }

    /* Hide the wrapper elements from screenreaders now that we've set the target's aria-label attribute. */
    if (opts.aria) {
        wrapper.setAttribute("aria-hidden", "true");
    }

    wrapper.appendChild(node.cloneNode(false));

    return wrapper;
}

function traverseDOM (node, opts) {
    let matchPosition = -1
    let skipNodeBit = 0

    /* Only proceed if the node is a text node and isn't empty. */
    if (node.nodeType === 3 && node.data.length) {
        /* Perform punctuation encoding/decoding once per original whole text node (before it gets split up into bits). */
        if (Element.nodeBeginning) {
            /* For the sentence delimiter, we first escape likely false-positive sentence-final punctuation. For all other delimiters,
               we must decode the user's manually-escaped punctuation so that the RegEx can match correctly (without being thrown off by characters in {{ASCII}}). */
            node.data = (!opts.search && opts.delimiter === "sentence") ? encodePunctuation(node.data) : decodePunctuation(node.data);

            Element.nodeBeginning = false;
        }

        matchPosition = node.data.search(delimiterRegex);

        /* If there's a RegEx match in this text node, proceed with element wrapping. */
        if (matchPosition !== -1) {
            var match = node.data.match(delimiterRegex),
                matchText = match[0],
                subMatchText = match[1] || false;

            /* RegEx queries that can return empty strings (e.g ".*") produce an empty matchText which throws the entire traversal process into an infinite loop due to the position index not incrementing.
               Thus, we bump up the position index manually, resulting in a zero-width split at this location followed by the continuation of the traversal process. */
            if (matchText === "") {
                matchPosition++;
            /* If a RegEx submatch is produced that is not identical to the full string match, use the submatch's index position and text.
               This technique allows us to avoid writing multi-part RegEx queries for submatch finding. */
            } else if (subMatchText && subMatchText !== matchText) {
                matchPosition += matchText.indexOf(subMatchText);
                matchText = subMatchText;
            }

            /* Split this text node into two separate nodes at the position of the match, returning the node that begins after the match position. */
            var middleBit = node.splitText(matchPosition);

            /* Split the newly-produced text node at the end of the match's text so that middleBit is a text node that consists solely of the matched text. The other newly-created text node, which begins
               at the end of the match's text, is what will be traversed in the subsequent loop (in order to find additional matches in the containing text node). */
            middleBit.splitText(matchText.length);

            /* Over-increment the loop counter (see below) so that we skip the extra node (middleBit) that we've just created (and already processed). */
            skipNodeBit = 1;

            if (!opts.search && opts.delimiter === "sentence") {
                /* Now that we've forcefully escaped all likely false-positive sentence-final punctuation, we must decode the punctuation back from ASCII. */
                middleBit.data = decodePunctuation(middleBit.data);
            }

            /* Create the wrapped node. */
            var wrappedNode = wrapNode(middleBit, opts, Element.blastedIndex);
            /* Then replace the middleBit text node with its wrapped version. */
            middleBit.parentNode.replaceChild(wrappedNode, middleBit);

            /* Push the wrapper onto the Element.wrappers array (for later use with stack manipulation). */
            Element.wrappers.push(wrappedNode);

            Element.blastedIndex++;

            /* Note: We use this slow splice-then-iterate method because every match needs to be converted into an HTML element node. A text node's text cannot have HTML elements inserted into it. */
            /* TODO: To improve performance, use documentFragments to delay node manipulation so that DOM queries and updates can be batched across elements. */
        }
    /* Traverse the DOM tree until we find text nodes. Skip script and style elements. Skip select and textarea elements since they contain special text nodes that users would not want wrapped.
       Additionally, check for the existence of our plugin's class to ensure that we do not retraverse elements that have already been blasted. */
    /* Note: This basic DOM traversal technique is copyright Johann Burkard <http://johannburkard.de>. Licensed under the MIT License: http://en.wikipedia.org/wiki/MIT_License */
    } else if (node.nodeType === 1 && node.hasChildNodes() && !Reg.skippedElements.test(node.tagName) && !Reg.hasPluginClass.test(node.className)) {
        /* Note: We don't cache childNodes' length since it's a live nodeList (which changes dynamically with the use of splitText() above). */
        for (var i = 0; i < node.childNodes.length; i++) {
            Element.nodeBeginning = true;

            i += traverseDOM(node.childNodes[i], opts);
        }
    }

    return skipNodeBit;
}

/*******************
   Call Variables
*******************/

// var opts = $.extend({}, $.fn[NAME].defaults, options),
//     delimiterRegex,
//     /* Container for variables specific to each element targeted by the Blast call. */
//     Element = {};

/****************
   main function
****************/

export default function (el, options = {}) {

    /***********************
       Delimiter Creation
    ***********************/


    elements.map(function(elem) {
        const text = getText(elem);

        /*****************
           Housekeeping
        *****************/

        /* Unless a consecutive opts.search is being performed, an element's existing Blast call is reversed before proceeding. */
        // TODO: Reimplement?
        // if ($this.data(NAME) !== undefined && ($this.data(NAME) !== "search" || opts.search === false)) {
        //     reverse(el, opts);
        //
        //     if (opts.debug) console.log(NAME + ": Removed element's existing Blast call.");
        // }

        /* Store the current delimiter type so that it can be compared against on subsequent calls (see above). */
        //$this.data(NAME, opts.search !== false ? "search" : opts.delimiter);

        if (opts.aria) {
            elem.setAttribute("aria-label", text);
        }

        /****************
           Preparation
        ****************/

        // TODO: Reimplement?
        /* Perform optional HTML tag stripping. */
        // if (opts.stripHTMLTags) {
        //     $this.html(text);
        // }

        /* If the browser throws an error for the provided element type (browers whitelist the letters and types of the elements they accept), fall back to using "span". */
        try {
            document.createElement(opts.tag);
        } catch (error) {
            opts.tag = "span";

            if (opts.debug) console.log(NAME + ": Invalid tag supplied. Defaulting to span.");
        }

        /* For reference purposes when reversing Blast, assign the target element a root class. */
        elem.classList.add(NAME + "-root");

        /* Initiate the DOM traversal process. */
        if (opts.debug) console.time(NAME);
        traverseDOM(elem, opts);
        if (opts.debug) console.timeEnd(NAME);

        /* If false is passed in as the first parameter, reverse Blast. */
        // } else if (options === false && $this.data(NAME) !== undefined) {
        //     reverse($this, opts);
        // }

        /**************
           Debugging
        **************/

        /* Output the full string of each wrapper element and color alternate the wrappers. This is in addition to the performance timing that has already been outputted. */
        // if (opts.debug) {
        //     $.each(Element.wrappers, function(index, element) {
        //         console.log(NAME + " [" + opts.delimiter + "] " + this.outerHTML);
        //         this.style.backgroundColor = index % 2 ? "#f12185" : "#075d9a";
        //     })
        // }
    })

    /*************
        Chain
    *************/

    /* Either return a stack composed of our call's Element.wrappers or return the element(s) originally targeted by the Blast call. */
    /* Note: returnGenerated can only be disabled on a per-call basis (not a per-element basis). */
    // if (options !== false && opts.returnGenerated === true) {
    //     /* A reimplementation of jQuery's $.pushStack() (since Zepto does not provide this function). */
    //     var newStack = $().add(Element.wrappers);
    //     newStack.prevObject = this;
    //     newStack.context = this.context;
    //
    //     return newStack;
    // } else {
    //     return this;
    // }
}
